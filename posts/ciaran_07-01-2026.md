---
title: JavaScript snippet breakdown
date: January 7, 2026
author: Ciaran
tags: [security, javascript]
excerpt: JavaScript snippet explained
---
# JavaScript is a language.

So look at the logic below:
```JavaScript 
console.log(~`${1}`.split``[0] >>> 31)
```
Guess at what it outputs:
- A) 0
- B) 1
- C) 4294967294
- D) 256

Spoiler Test: || Thats right :D its [REDACTED]! ||

## But why?? What happen here?

ok so 
Template literals (${â€¦}``) always produce strings.

```js
`${1}` === "1"
```

Even though `1` is a number, interpolation forces it thru `ToString`

So after this step, we have:
```js
"1"
```

### Template literal r weird

Yoi may be used to seeing templates (``) used normally in a lot of places, however they do have some hidden weirdness (which is often the case with JS). Yuo may not know but in JavaScript, any function can be called as a tagged template.

So when you do:
```js
"1".split``
```

What actually happens is:
```js
"1".split([""])
```

Because a tagged template with no content produces an array containing a single empty string: [""].
And since `String.prototype.split` expects a separator `[""]` is coerced to `""`.

So this becomes:
```js
"1".split("")
```

Which yields:
```js
["1"]
```

Then immediately indexing with 0:
```js
["1"][0]
```

We're right back to the string "1".

### More coersion 
Then after that the bitwise NOT operator (~) forces its operand through `ToInt32`.
"1" -> 1 (00000000 00000000 00000000 00000001)

Bitwise NOT flips all bits so it becomes:

-2 (11111111 11111111 11111111 11111110)

Then we shift right by 31 bits with >>> 31 and it go right back to:

00000000 00000000 00000000 00000001

Which becomes 1 again :3


(Quick bullet point test)

- Lot of implicit coercion (string -> number -> int32 -> uint32)
- Tagged templates being function calls
- Bitwise stuff
- Using >>> 31 to extract the sign bit
